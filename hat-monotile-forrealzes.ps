%!

% Some convenient 2d-vector operations

/vadd {                 % [x1 y1] [x2 y2] >>> [x1+x2 y1+y2]
    aload pop           % [x1 y1] x2 y2
    3 -1 roll           % x2 y2 [x1 y1]
    aload pop           % x2 y2 x1 y1
    3 -1 roll           % x2 x1 y1 y2
    add                 % x2 x1 y1+y2
    3 1 roll            % y1+y2 x2 x1
    add                 % y1+y2 x2+x1
    exch                % x2+x1 y1+y2
    2 array astore      % [x1+x2 y1+y2]
} def

/vneg {                 % [x y] >>> [-x -y]
    aload pop
    neg exch neg exch
    2 array astore
} def

/vsub {                 % [x1 y1] [x2 y2] >>> [x1-x2 y1-y2]
    vneg
    vadd
} def

/vmul {                 % [x y] m >>> [x*m y*m]
    exch aload pop      % m x y
    2 index             % m x y m
    mul                 % m x y*m
    3 1 roll            % y*m m x
    mul                 % y*m x*m
    exch
    2 array astore
} def

/midpoint {             % [x1 y1] [x2 y2] >>> [(x1+x2)/2 (y1+y2)/2]
    vadd
    .5 vmul
} def

/vmeasure {             % [x y] >>> sqrt(x^2+y^2)
    aload pop           % x y
    dup mul             % x y*y
    exch dup mul        % y*y x*x
    add                 % x*x+y*y
    sqrt                % sqrt(x^2+y^2)
} def

/vrot {                 % [x y] r >>> [xr yr]
    dup cos             % [x y] r cos(r)
    exch sin            % [x y] cos(r) sin(r)
    3 -1 roll           % cos(r) sin(r) [x y]
    dup                 % cos(r) sin(r) [x y] [x y]
    aload pop           % cos(r) sin(r) [x y] x y
    3 index             % cos(r) sin(r) [x y] x y sin(r)
    neg                 % cos(r) sin(r) [x y] x y -sin(r)
    mul                 % cos(r) sin(r) [x y] x -y*sin(r)
    exch                % cos(r) sin(r) [x y] -y*sin(r) x
    4 index             % cos(r) sin(r) [x y] -y*sin(r) x cos(r)
    mul                 % cos(r) sin(r) [x y] -y*sin(r) x*cos(r)
    add                 % cos(r) sin(r) [x y] x*cos(r)-y*sin(r)  // the new X
    exch aload pop      % cos(r) sin(r) x*cos(r)-y*sin(r) x y
    5 -1 roll           % sin(r) x*cos(r)-y*sin(r) x y cos(r)
    mul                 % sin(r) x*cos(r)-y*sin(r) x y*cos(r)
    exch                % sin(r) x*cos(r)-y*sin(r) y*cos(r) x
    4 -1 roll           % x*cos(r)-y*sin(r) y*cos(r) x sin(r)
    mul                 % x*cos(r)y*sin(r) y*cos(r) x*sin(r)
    add                 % x*cos(r)-y*sin(r) x*sin(r)+y*cos(r)
    2 array astore
} def


% % Intersect line segment [[x1 y1] [x2 y2]] with [[x3 y3] [x4 y4]]

/vintersect {        % [x1 y1] [x2 y2] [x3 y3] [x4 y4] >>> ---
    11 dict begin
    aload pop /y4 exch def /x4 exch def
    aload pop /y3 exch def /x3 exch def
    aload pop /y2 exch def /x2 exch def
    aload pop /y1 exch def /x1 exch def

    /denominator
      x1 x2 sub y3 y4 sub mul
      y1 y2 sub x3 x4 sub mul sub
    def

      x1 y2 mul y1 x2 mul sub x3 x4 sub mul
      x3 y4 mul y3 x4 mul sub x1 x2 sub mul sub
      denominator div

      x1 y2 mul y1 x2 mul sub y3 y4 sub mul
      x3 y4 mul y3 x4 mul sub y1 y2 sub mul sub
      denominator div
      2 array astore
      end
} def


% symmetries

/hmirror {              % [x y] >>> [x -y]
    aload pop
    neg
    2 array astore
} def

/vmirror {              % [x y] >>> [-x y]
    aload pop
    exch neg exch
    2 array astore
} def

/opposite {             % [x y] >>> [-x -y]
    hmirror vmirror
} def

% translate an array of vectors
/vtranslate {              % [[x1 y1] [x2 y2] ...] [x y] >>> [[x1t y1t] [x2t y2t] ...]
    1 dict begin
    /trans exch def
    mark exch
    {
        trans vadd
    } forall
    end
    counttomark
    array astore
    exch pop
} def

% rotate an array of vectors
/vrotate {              % [[x1 y1] [x2 y2] ...] r >>> [[x1r y1r] [x2r y2r] ...]
    1 dict begin
    /angle exch def
    mark exch
    {
        angle vrot
    } forall
    end
    counttomark
    array astore
    exch pop
} def

% flip left-right an array of vectors
/vflip {                % [[x1 y1] [x2 y2] ...] >>> [[-x1 y1] [-x2 y2] ...]
    mark exch
    {
        vmirror
    } forall
    counttomark
    array astore
    exch pop
} def

%
%                     E------M------D
%                    /               \
%                   /                 \
%                  N                   L
%                 /                     \
%                /                       \
%               F            O            C
%                \                       /   E------M------D
%                 \         "red"       /   /               \
%                  P                   K   /                 \
%                   \                 /   N                   L
%                    \               /   /                     \
%                     A------J------B   /                       \
%                                      F            O            C
%                     E------M------D   \                       /
%                    /               \   \       "green"       /
%                   /                 \   P                   K
%                  N                   L   \                 /
%                 /                     \   \               /
%                /                       \   A------J------B
%               F            O            C
%                \                       /
%                 \      "black"        /
%                  P                   K
%                   \                 /
%                    \               /
%                     A------J------B
%
%
%   O: (   0,     0)
%   A: (-1/2, -sq32)
%   B: ( 1/2, -sq32)
%   C: (   1,     0)
%   D: ( 1/2,  sq32)
%   E: (-1/2,  sq32)
%   F: (  -1,     0)
%

/half .5 def
/sq32 3 sqrt 2 div def

/O [ 0 0 ] def
/A [ half neg sq32 neg ] def
/B A vmirror def
/C [ 1 0 ] def
/D A opposite def
/E A hmirror def
/F C vmirror def

/J A B midpoint def
/K B C midpoint def
/L C D midpoint def
/M D E midpoint def
/N E F midpoint def
/P F A midpoint def

/black2red {
    % add the vector AE
    E A vneg vadd vadd
} def

/black2green {
    % add the vector AC
    C A vneg vadd vadd
} def



/cshow { dup stringwidth pop -2 div 0 rmoveto show } def  % XXX

/apath {                        % hatarray strokeproc fillproc >>> -
    2 dict begin
    /fillproc exch def
    /strokeproc exch def
    gsave
        newpath
        dup 0 get aload pop moveto          % moveto the CAR
        dup length 1 sub 1 exch getinterval % lineto the CDR
        {
            aload pop lineto
        } forall
        closepath
        gsave fillproc grestore
        gsave strokeproc grestore
    grestore
    end
} def

/hat-upright [
    O
    L
    C
    B black2green
    K black2green
    O black2green
    M black2green
    E black2green
    L black2red
    O black2red
    M
    E
    N
] def
/hat-flipped hat-upright vflip def


/point-O 0 def
/point-L 1 def
/point-C 2 def
/point-Bg 3 def
/point-Kg 4 def
/point-Og 5 def
/point-Mg 6 def
/point-Eg 7 def
/point-Lr 8 def
/point-Or 9 def
/point-M 10 def
/point-E 11 def
/point-N 12 def






%% main()

/strk {
    { 1 setlinejoin .05 setlinewidth stroke }
} def

/strkk {
    { 1 setlinejoin .025 setlinewidth stroke }
} def

/strkr {
    { 1 setlinejoin .025 setlinewidth 1 0 0 setrgbcolor stroke }
} def

/strkg {
    { 1 setlinejoin .025 setlinewidth 0 1 0 setrgbcolor stroke }
} def
/strkb {
    { 1 setlinejoin .025 setlinewidth 0 0 1 setrgbcolor stroke }
} def

/strkc {
    { 1 setlinejoin .025 setlinewidth 1 0 0 0 setcmykcolor stroke }
} def

/strkm {
    { 1 setlinejoin .025 setlinewidth 0 1 0 0 setcmykcolor stroke }
} def
/strky {
    { 1 setlinejoin .025 setlinewidth 0 0 1 0 setcmykcolor stroke }
} def

/fillk {
    { 0 0 0 1 setcmykcolor fill }
} def

/fillc {
    { 1 0 0 0 setcmykcolor fill }
} def

/fillm {
    { 0 1 0 0 setcmykcolor fill }
} def

/filly {
    { 0 0 1 0 setcmykcolor fill }
} def

/fillw {
    { 0 0 0 0 setcmykcolor fill }
} def


/sky {
    { .6 .8 .9 setrgbcolor fill }
} def

/azure {
    { 0 .55 .9 setrgbcolor fill }
} def

/grey {
    { .75 setgray fill }
} def

/white {
    { 1 setgray fill }
} def


/scalefactor 30 def
300 400 translate
scalefactor dup scale
/HelveticaBold findfont 18 scalefactor div scalefont setfont
/targetmark {
    gsave
    .2 scalefactor div setlinewidth
    newpath
    0 0
    .1 0 360 arc
    closepath stroke
    1 0 0 setrgbcolor
    newpath
    0 -.1 moveto 0 .1 lineto
    -.1 0 moveto .1 0 lineto
    stroke
    grestore
} def

/hat-q-central
    hat-upright
    -60 vrotate
def

/hat-q-bottom {
    hat-q-central vflip
    -60 vrotate
    dup
    point-Og get
    vneg
    vtranslate
} def

/hat-q-top
    hat-upright
    vflip
    120 vrotate
    dup
    8 get vneg
    hat-q-central 12 get
    vadd
    vtranslate
def

/hat-q-right
    hat-upright
    vflip
    -120 vrotate
    hat-q-central 5 get vtranslate
def

/hat-q-left
    hat-upright
    vflip
    -120 vrotate
    dup
    5 get
    vneg
    vtranslate
def

/et-left-anchor hat-q-left 0 get def
/et-right-anchor hat-q-right 9 get def
/et-top-anchor hat-q-top 0 get def
/enclosing-triangle [
    et-left-anchor
    hat-q-left 11 get
    et-right-anchor
    hat-q-right 7 get
    et-top-anchor
    hat-q-top 11 get
] def

/enclosing-triangle-centroid
  et-top-anchor et-right-anchor midpoint et-left-anchor
  et-top-anchor et-left-anchor midpoint et-right-anchor
  def


/trqtile {              % etrp strkpr odrpr idrpr rot [x y] >>> -
    6 2 roll            % rot [x y] etrp strkpr odrpr idrpr

    hat-q-central       % rot [x y] etrp strkpr odrpr idrpr array
    6 index vrotate     % rot [x y] etrp strkpr odrpr idrpr array-r
    5 index vtranslate  % rot [x y] etrp strkpr odrpr idrpr array-r-t
    exch                % rot [x y] etrp strkpr odrpr array-r idrpr
    3 index exch        % rot [x y] etrp strkpr odrpr array-r strkpr idrpr
    apath               % rot [x y] etrp strkpr odrpr

    hat-q-right         % rot [x y] etrp strkpr odrpr array
    5 index vrotate     % rot [x y] etrp strkpr odrpr array-r
    4 index vtranslate  % rot [x y] etrp strkpr odrpr array-r-t
    2 index 2 index
    apath               % rot [x y] etrp strkpr odrpr

    hat-q-left          % rot [x y] etrp strkpr odrpr array
    5 index vrotate
    4 index vtranslate  % rot [x y] etrp strkpr odrpr array-r-t
    2 index 2 index
    apath               % rot [x y] etrp strkpr odrpr

    hat-q-top           % rot [x y] etrp strkpr odrpr array
    5 index vrotate     % rot [x y] etrp strkpr odrpr array-r
    4 index vtranslate  % rot [x y] etrp strkpr odrpr array-r-t
    3 1 roll            % rot [x y] etrp array-r-t strkpr odrpr
    apath               % rot [x y] etrp
    {
        enclosing-triangle % rot [x y] array
        3 -1 roll          % [x y] array rot
        vrotate            % [x y] array-r
        exch               % array-r [x y]
        vtranslate         % array-r-t
        strk {} apath
    }
    {
        pop pop
    } ifelse
%    hat-q-left 0 get gsave aload pop translate targetmark grestore
} def

/qtile {    % etrp strkpr odrpr idrpr  >>> ---
    hat-q-central exch 3 index exch apath
    hat-q-right 2 index 2 index apath
    hat-q-left 2 index 2 index apath
    hat-q-top 3 1 roll apath
    { enclosing-triangle strk {} apath } if
%    hat-q-left 0 get gsave aload pop translate targetmark grestore
} def




/hat-p-point
    hat-flipped
%    dup 0 get    gsave aload pop translate targetmark grestore
def

/hat-p-fletching
    hat-p-point
    -60 vrotate
    dup
    10 get
    hat-p-point
    4 get
    exch
    vsub
    vtranslate
 %   dup 0 get    gsave aload pop translate targetmark grestore
def

% dup 0 get    gsave aload pop translate targetmark grestore

/ea-front-anchor hat-p-point 9 get def
/enclosing-arrow [
        ea-front-anchor
        hat-p-fletching 3 get
        hat-p-fletching 0 get
        hat-p-point 0 get
        hat-p-point 11 get
] def


/trgtile {              % eap strkpr drpr rot [x y]   >>> -
    5 2 roll            % rot [x y] eap strkpr drpr
    hat-p-point         % rot [x y] eap strkpr drpr array
    5 index vrotate     % rot [x y] eap strkpr drpr array-r
    4 index vtranslate  % rot [x y] eap strkpr drpr array-r-t
    2 index             % rot [x y] eap strkpr drpr array-r-t strkpr
    2 index             % rot [x y] eap strkpr drpr array-r-t strkpr drpr
    apath               % rot [x y] eap strkpr drpr

    hat-p-fletching     % rot [x y] eap strkpr drpr array
    5 index vrotate     % rot [x y] eap strkpr drpr array-r
    4 index vtranslate  % rot [x y] eap strkpr drpr array-r-t
    3 1 roll            % rot [x y] eap array-r-t strkpr drpr
    apath               % rot [x y] eap

    {
        enclosing-arrow   % rot [x y] array
        3 -1 roll         % [x y] array rot
        vrotate           % [x y] array-r
        exch vtranslate   % array-r-t
        strk {}
        apath
    }
    {
        pop
        pop
    } ifelse
} def

/gtile {
    hat-p-point 2 index 2 index apath
    hat-p-fletching 3 1 roll apath
    { enclosing-arrow strk {} apath } if
} def



/rightbigtile {
    dup dup

    strkk sky azure qtile
    gsave
        hat-q-central 4 get
        hat-p-point 6 get
        vsub
        aload pop
        translate
        strkk grey gtile
    grestore

    gsave
        hat-q-right 5 get
        aload pop
        translate
        -60 rotate
        strkk white gtile
    grestore
} def

/leftbigtile {
    dup dup
    strkk sky azure 0 [0 0] trqtile
    gsave
        hat-q-left 0 get
        hat-p-point 9 get -120 vrot
        vsub
        aload pop translate
        -120 rotate
        strkk grey gtile
    grestore

    gsave
        hat-q-central 4 get
        hat-p-point 6 get
        vsub
        aload pop
        translate
        strkk white gtile
    grestore
} def

/theta 0 def
/offset [2 3] def


    dup dup
    strkk sky azure
    theta offset trqtile


    strkm {}
    -120
    theta add

    hat-q-left 0 get
    -120 theta add vrot

    hat-p-point 9 get
    -120
    theta add
    vrot
    vsub
    % [2 3] vadd
    offset vadd

    trgtile

    % gsave
    %     hat-q-left 0 get
    %     hat-p-point 9 get -120 vrot
    %     vsub
    %     aload pop translate
    %     -120 rotate
    %     strkk grey gtile
    % grestore

    % gsave
    %     hat-q-central 4 get
    %     hat-p-point 6 get
    %     vsub
    %     aload pop
    %     translate
    %     strkk white gtile
    % grestore
} def



% gs hat-monotile-forrealzes.ps


% GS>leftbigtile
% GS>hat-q-right 0 get tc
% GS>hat-q-right 9 get tc
% GS>hat-q-left 0 get tm
% GS>hat-q-right 9 get
% GS<1>hat-q-left 0 get
% GS<2>vsub
% GS<1>gsave aload translate

% GS<3>pop translate
% GS>rightbigtile
% GS>[0 0] ty


% rightbigtile
% hat-q-left 0 get hat-q-top 0 get vsub
% gsave aload pop translate leftbigtile grestore


/tt { gsave newpath aload pop .1 0 360 arc fill grestore } def
/tc { gsave 1 0 0 0 setcmykcolor tt grestore } def
/tm { gsave 0 1 0 0 setcmykcolor tt grestore } def
/ty { gsave 0 0 1 0 setcmykcolor tt grestore } def

/pt { gsave newpath aload pop .05 0 360 arc fill grestore } def
/pr { gsave 1 0 0 setrgbcolor pt grestore } def
/pg { gsave 0 1 0 setrgbcolor pt grestore } def
/pb { gsave 0 0 1 setrgbcolor pt grestore } def

% rightbigtile

% /mtile
% hat-q-right 7 get
% hat-p-point 6 get
% vsub


/gtile2 {                % draw-encloser? fillproc >>> ---
    dup                 % draw-encloser? fillproc fillproc
    hat-p-point         % draw-encloser? fillproc fillproc tophat
% dup 0 get    gsave aload pop translate targetmark grestore
    exch                % draw-encloser? fillproc tophat fillproc
    strkk               % draw-encloser? fillproc tophat fillproc strk
    exch                % draw-encloser? fillproc tophat strk fillproc
    apath               % draw-encloser? fillproc
    hat-p-fletching     % draw-encloser? fillproc bothat
    exch                % draw-encloser? bothat fillproc
    strkk               % draw-encloser? bothat fillproc strkk
    exch                % draw-encloser? bothat strkk fillproc
    apath               % draw-encloser?
    [
        hat-p-point 0 get
        hat-p-point 11 get
        hat-p-point 9 get
        hat-p-fletching 3 get
        hat-p-fletching 0 get
    ]
    exch {strk} {{}} ifelse {} apath
} def

/supertile {
    false qtile
    gsave
        hat-q-top 0 get
        hat-p-point 9 get vsub
        aload pop translate
        false grey gtile
    grestore
    gsave
        -3 0 translate
        120 rotate
        false {} gtile
    grestore
} def

% false grey gtile

% supertile
% gsave
% -1.5 -3.5 sq32 sub translate 120 rotate supertile
% -1.5 -3.5 sq32 sub translate 120 rotate supertile
% grestore

% hat-central strkk azure apath   %

% Center FINAL

% hat-left strkk {} apath
% hat-left 0 get
% gsave aload pop translate targetmark grestore

% hat-top 8 get

% dup
%  strkc {} apath
% gsave  8 get aload pop translate targetmark grestore

% /hat-right {
%     hat-central vflip
%     -60 vrotate
%     hat-central point-Og get
%     vtranslate
% } def

% /hat-left {
%     hat-central vflip
%     180 vrotate
%     dup
%     point-Mg get vneg
%     hat-central point-M get
%     vadd
%     vtranslate
% } def


/tile0 {
    hat-central strkk azure apath
    hat-right strkk fillm apath
    hat-left strkk filly apath
    hat-bottom strkk fillc apath
    enclosing-triangle {} {} apath
    % gsave aload pop translate targetmark grestore
    pop
} def

/tilest {
    hat-central strkk {} apath
    hat-right strkm {} apath
    hat-left strky {} apath
    hat-bottom strkc {} apath
    enclosing-triangle {} {} apath
    % gsave aload pop translate targetmark grestore
    pop
} def

% /hat-cyan hat-bottom def
% /hat-yellow hat-left def
% /hat-magenta hat-right def



/qtile0 {
    hat-central strkk azure apath
    hat-right strkk sky apath
    hat-left strkk sky apath
    hat-bottom strkk sky apath
    enclosing-triangle
    exch {strk} {{}} ifelse {} apath
    % gsave aload pop translate targetmark grestore
} def




/supertile {
    gsave
    false qtile
    -1.5 sq32 3 mul translate
    false dtile targetmark
    grestore
} def


% -2 -3 translate 120 rotate supertile

% -1.5 -2.5 translate 120 rotate supertile




/FF [
    [0 0]
    [1 0]
    [1 1]
    [2 1]
    [2 2]
    [1 2]
    [1 3]
    [2 3]
    [2 4]
    [0 4]
] def


% gsave
% FF strk {} apath
% grestore

% gsave
% FF 45 vrotate vflip   strkr {} apath
% [1 1] vmirror 45 vrot aload pop translate targetmark
% grestore


% gsave

% grestore

% targetmark


/pointgrid {
    -11 1 11 {
        -9 1 9 {
            1 index 2 array astore pg
        } for
        0 exch 2 array astore pr
    } for
    -9 1 9 {
        0 2 array astore pr
    } for
} def
